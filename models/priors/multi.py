from typing import Optional, Tuple, List, Sequence
import torch

from orquestra.qml.api import TorchGenerativeModel, TrainResult, Batch


class MultiSampler(TorchGenerativeModel):
    _repr_fields = ["sampler", "recipe", "sample_size"]
    
    def __init__(
        self,
        sampler: TorchGenerativeModel,
        recipe: Sequence[int],
        dtype: torch.dtype = torch.float32,
    ) -> None:
        """Allows to wrap a base ``sampler`` and generate and stack multiple samples from it,
        according to the ``recipe`` argument.
        
        Args:
            sampler (TorchGenerativeModel): model used to generate samples.
            recipe (Sequence[int]): an instruction on how many times to sample from the ``sampler`` along each dimension
                and how to stack the samples. For example, if ``recipe = (2, 3)`` and the ``sampler`` generates 2D samples,
                of shape ``(n_samples, d)``, then the output will be of shape ``(n_samples, 2, 3 * d)``. If ``recipe = (2,)``, 
                and the same ``sampler`` is used then the output will be of shape ``(n_samples, 2 * d)``.
                Currently, only 1D and 2D sequences are supported.                
            dtype (torch.dtype): dtype of the output tensor. Defaults to torch.float32.
        """
        super().__init__()
        self.sampler = sampler
        
        if len(recipe) > 2:
            raise ValueError("Currently, only 1D and 2D sequences are supported.")
        
        self.recipe = recipe
        self._dtype = dtype
        self.raw_samples = []
        self.raw_rewards_end = 0
    
    def _train_on_batch(self, batch: Batch[torch.Tensor]) -> TrainResult:
        return self.sampler._train_on_batch(batch)

    def config(self) -> dict:
        """Returns a dictionary containing the configuration of the sampler.
        """
        d = {
            "name": self.__class__.__name__,
            "recipe": self.recipe,
            "sample_size": self.sample_size,
            "dtype": str(self.dtype),
        }
        return d

    def as_string(self) -> str:
        """Returns a string representation of the sampler.
        """
        name = self.__class__.__name__
        sampler_name = self.sampler.__class__.__name__
        s = f"{name}(recipe={self.recipe}, sampler={sampler_name})"
        return s
    
    def _generate_2d(self, n_samples: int, random_seed: Optional[int] = None) -> torch.Tensor:
        sample_dim = self.sampler.sample_size[-1]
        n_repeats = self.recipe[0]
        
        output = torch.zeros(
            (n_samples, n_repeats * sample_dim), dtype=self.dtype,
        )
        raw_samples = []
        for i in range(n_repeats):
            sample = torch.tensor(self.sampler.generate(n_samples, random_seed))
            output[:, i * sample_dim : (i + 1) * sample_dim] = sample
            raw_samples.append(sample)
        self.raw_rewards_end = n_repeats
        self.raw_samples = torch.cat(raw_samples,dim=0)
        return output
    
    def _generate_3d(self, n_samples: int, random_seed: Optional[int] = None) -> torch.Tensor:
        sample_dim = self.sampler.sample_size[-1]
        n_repeats_d1, n_repeats_d2 = self.recipe
        
        output = torch.zeros(
            (n_samples, n_repeats_d1, n_repeats_d2 * sample_dim), dtype=self.dtype,
        )
        self.raw_samples = []
        # TODO: append all the samples generated by prior to be trainable 
        for i_d1 in range(n_repeats_d1):
            for i_d2 in range(n_repeats_d2):
                sample = torch.tensor(self.sampler.generate(n_samples, random_seed))
                self.raw_samples.append(sample)
                output[:, i_d1, i_d2 * sample_dim : (i_d2 + 1) * sample_dim] = sample
        self.raw_rewards_end = i_d2
        
        return output
    
    def _generate(self, n_samples: int, random_seed: Optional[int] = None) -> torch.Tensor:
        """Generates samples from the sampler.

        Args:
            n_samples (int): The number of samples to generate.
            random_seed (Optional[int], optional): The random seed to use. Defaults to None.

        Returns:
            torch.Tensor: The generated samples.
        """
        generate_fn = self._generate_2d if len(self.recipe) == 1 else self._generate_3d
        return generate_fn(n_samples, random_seed)
    
    @property
    def dtype(self) -> torch.dtype:
        return self._dtype
    
    @property
    def sample_size(self) -> Tuple[int, ...]:
        sample_dim = self.sampler.sample_size[-1]
        if len(self.recipe) == 1:
            return (self.recipe[0] * sample_dim,)
        else:
            return (self.recipe[0], self.recipe[1] * sample_dim)
    
    @property
    def _models(self) -> List[torch.nn.Module]:
        return []